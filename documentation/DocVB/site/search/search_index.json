{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to VB Documentation This is Our Documentation for Our Solution to Vargi Bot Theme for Eyantra Competition 2020-21 Explanation Summary - A brief explanation Implementation - Proper Explanation of each block of code Packages - pkg_task5 - Documentation of Dispatch and Shipping nodes pkg_ros_iot_bridge - Documentation of Action Server and IoT py files message and config - Documentation of message and config files","title":"Home"},{"location":"#welcome-to-vb-documentation","text":"This is Our Documentation for Our Solution to Vargi Bot Theme for Eyantra Competition 2020-21","title":"Welcome to VB Documentation"},{"location":"#explanation","text":"Summary - A brief explanation Implementation - Proper Explanation of each block of code","title":"Explanation"},{"location":"#packages-","text":"pkg_task5 - Documentation of Dispatch and Shipping nodes pkg_ros_iot_bridge - Documentation of Action Server and IoT py files message and config - Documentation of message and config files","title":"Packages -"},{"location":"cnfg/","text":"This Documentation covers the contents of config folder in pkg_ros_iot_bridge and pkg_task5 config_pyiot.yaml directory - pkg_ros_iot_bridge/config * This is a .yaml file that comprises the different IoT gateways sign up details config_pyiot: mqtt: server_url: \"broker.mqttdashboard.com\" server_port: 1883 topic_sub: \"/eyrc/vb/giLGamsh/orders\" topic_pub: \"eyrc/giLGamsh/ros_to_iot\" qos: 0 rviz directory - pkg_task5/config The 2 Moveit Planning Scenes One for Ur5_1 : shelf.scene One for Ur5_2 : bins.scene Saved Trajectories directory - pkg_task5/config The .yaml file that contains the already computed collision-free path for a ur5 arm to travel between two poses package_xx: It is the saved trajectory between the conveyor belt position of Ur5 arm and the respective package package_xx_to_cb: It is the saved trajectory between the the respective package and conveyor belt position of Ur5 arm","title":"the config folder"},{"location":"cnfg/#this-documentation-covers-the-contents-of-config-folder-in-pkg_ros_iot_bridge-and-pkg_task5","text":"","title":"This Documentation covers the contents of config folder in pkg_ros_iot_bridge and pkg_task5"},{"location":"cnfg/#config_pyiotyaml","text":"directory - pkg_ros_iot_bridge/config * This is a .yaml file that comprises the different IoT gateways sign up details config_pyiot: mqtt: server_url: \"broker.mqttdashboard.com\" server_port: 1883 topic_sub: \"/eyrc/vb/giLGamsh/orders\" topic_pub: \"eyrc/giLGamsh/ros_to_iot\" qos: 0","title":"config_pyiot.yaml"},{"location":"cnfg/#rviz","text":"directory - pkg_task5/config The 2 Moveit Planning Scenes One for Ur5_1 : shelf.scene One for Ur5_2 : bins.scene","title":"rviz"},{"location":"cnfg/#saved-trajectories","text":"directory - pkg_task5/config The .yaml file that contains the already computed collision-free path for a ur5 arm to travel between two poses package_xx: It is the saved trajectory between the conveyor belt position of Ur5 arm and the respective package package_xx_to_cb: It is the saved trajectory between the the respective package and conveyor belt position of Ur5 arm","title":"Saved Trajectories"},{"location":"impl/","text":"What we did to find the solution to Vargi Bot theme objective? Step-1 We went through lines and lines of codes related to pyzbar and cv2, which in turn is used by the 2d Camera. The same small object near the UR5_1 arm on the left side of the task world. It captures an image, but an image which it interprets in the form of Numpy array. The image itself was not clear enough to identify all 12 packages located on the shelf. So we did some image clearing, removed the noise, changed it to black and white among others. After that we got a clear image of 12 packages. The next step was to decode the qr code located on each of the package. It came out to be another array, but then we found out about the unique values in the rectangle coordinates. We then sorted these coordinates in ascending order of x and y coordinates. We had to sort the array thrice, once along x-axis, once along y-axis, and the last just because the x and y values were not too much unique, so we again sorted in the batch of three. Then we finally got the different values of colours for different package. Step-2 After we get the sorted colours according to the packages in the shelf, we send this list to the node-2, ( using ) which is the ur5_2 arm, where the packages are going to get Shipped. Meanwhile both the UR5_1 and UR5_2 arms travels and sets the joint angles facing the conveyor belt and the action-server ( This ) gets active. Step-3 The next step is sending the sorted colour list to the action server via the action client ( client ) stating that we want to append the \"inventory\" sheet. From there it is sent to the iot py node Upadte Inventory wherein some math and string functions are used and data is appended. Step-4 We Wait till Sim-Time reaches 60 seconds(or one minute), after which the action server starts publishing the incoming orders on a rospy topic specified. The UR5_1 node collects this order and appends it on a global list in the python node. ( This fnx ). The values are aslo pushed to incomming orders sheet Step-5 We now get the package using the last element of the global lists of order inside the python node. If the list has more than 1 element, then it is sorted on the basis of the order id Since we saw that the order id is unique and starts with '1' for High Priority, '2' for Medium and '3' for Low Priority package. So Sorting the Order IDs in descending order seemed more viable. We found out which package to chose using the same Order ID. If it ends with 1, then it is in the first row. If 2, then second row and so on....... Meanwhile the order details of the package about to get dispatched is published on the rostopic. ( Orders ) Step-6 Now our UR5_1 arm starts from its conveyor belt position for the package using the already saved trajectories in our config folder. ( Config Folder ). Attaches the package using the method defined in Class ur5moveit and travels back along the path already saved to the conveyor belt. Step-7 The attached package is dropped at the conveyor belt and its subsequent details are pushed to the action server to update the Dispatched Orders Sheet and the package goes to the ur5_2 arm using conveyor belt. Step-8 The second Node ( ur5_2 ) which is constantly subscribed to the logical camera 2 messages checks for an upcoming package. When the package is just under the camera and also the UR5_2 arm, its y coordinate reaches 0 w.r.t. the logical camera 2. Then the conveyor belt is stopped and the UR5_2 attaches the package It checks for the colour of the package_XX using some math and the \"XX\" in the sorted color list it got from node 1 defined in the Cartesian Path class. The UR5_2 travels to the respective colored bin and drops the package. The OrdersShipped Sheet is appended using the action server and class The Above Step-5 to Step-8 are followed when different orders are recieved on different intervals of time Our implementation works for all the packages and orders we recieved on our End. Thank you for reading the Documentation page. I have been very careful in dding all the links wherever it is needed. We Worked hard for the last few weeks to get this implementation working Regards, Tushar Kanti Jaiswal Team VB#0602","title":"Implementation"},{"location":"impl/#what-we-did-to-find-the-solution-to-vargi-bot-theme-objective","text":"","title":"What we did to find the solution to Vargi Bot theme objective?"},{"location":"impl/#step-1","text":"We went through lines and lines of codes related to pyzbar and cv2, which in turn is used by the 2d Camera. The same small object near the UR5_1 arm on the left side of the task world. It captures an image, but an image which it interprets in the form of Numpy array. The image itself was not clear enough to identify all 12 packages located on the shelf. So we did some image clearing, removed the noise, changed it to black and white among others. After that we got a clear image of 12 packages. The next step was to decode the qr code located on each of the package. It came out to be another array, but then we found out about the unique values in the rectangle coordinates. We then sorted these coordinates in ascending order of x and y coordinates. We had to sort the array thrice, once along x-axis, once along y-axis, and the last just because the x and y values were not too much unique, so we again sorted in the batch of three. Then we finally got the different values of colours for different package.","title":"Step-1"},{"location":"impl/#step-2","text":"After we get the sorted colours according to the packages in the shelf, we send this list to the node-2, ( using ) which is the ur5_2 arm, where the packages are going to get Shipped. Meanwhile both the UR5_1 and UR5_2 arms travels and sets the joint angles facing the conveyor belt and the action-server ( This ) gets active.","title":"Step-2"},{"location":"impl/#step-3","text":"The next step is sending the sorted colour list to the action server via the action client ( client ) stating that we want to append the \"inventory\" sheet. From there it is sent to the iot py node Upadte Inventory wherein some math and string functions are used and data is appended.","title":"Step-3"},{"location":"impl/#step-4","text":"We Wait till Sim-Time reaches 60 seconds(or one minute), after which the action server starts publishing the incoming orders on a rospy topic specified. The UR5_1 node collects this order and appends it on a global list in the python node. ( This fnx ). The values are aslo pushed to incomming orders sheet","title":"Step-4"},{"location":"impl/#step-5","text":"We now get the package using the last element of the global lists of order inside the python node. If the list has more than 1 element, then it is sorted on the basis of the order id Since we saw that the order id is unique and starts with '1' for High Priority, '2' for Medium and '3' for Low Priority package. So Sorting the Order IDs in descending order seemed more viable. We found out which package to chose using the same Order ID. If it ends with 1, then it is in the first row. If 2, then second row and so on....... Meanwhile the order details of the package about to get dispatched is published on the rostopic. ( Orders )","title":"Step-5"},{"location":"impl/#step-6","text":"Now our UR5_1 arm starts from its conveyor belt position for the package using the already saved trajectories in our config folder. ( Config Folder ). Attaches the package using the method defined in Class ur5moveit and travels back along the path already saved to the conveyor belt.","title":"Step-6"},{"location":"impl/#step-7","text":"The attached package is dropped at the conveyor belt and its subsequent details are pushed to the action server to update the Dispatched Orders Sheet and the package goes to the ur5_2 arm using conveyor belt.","title":"Step-7"},{"location":"impl/#step-8","text":"The second Node ( ur5_2 ) which is constantly subscribed to the logical camera 2 messages checks for an upcoming package. When the package is just under the camera and also the UR5_2 arm, its y coordinate reaches 0 w.r.t. the logical camera 2. Then the conveyor belt is stopped and the UR5_2 attaches the package It checks for the colour of the package_XX using some math and the \"XX\" in the sorted color list it got from node 1 defined in the Cartesian Path class. The UR5_2 travels to the respective colored bin and drops the package. The OrdersShipped Sheet is appended using the action server and class The Above Step-5 to Step-8 are followed when different orders are recieved on different intervals of time Our implementation works for all the packages and orders we recieved on our End. Thank you for reading the Documentation page. I have been very careful in dding all the links wherever it is needed. We Worked hard for the last few weeks to get this implementation working Regards, Tushar Kanti Jaiswal Team VB#0602","title":"Step-8"},{"location":"iot/","text":"This Documentation covers the working of the IoT py file Function for updating inventory sheet - update_inventory(arg_colorlist): This function appends the inventory sheet of the inventory management spreadsheet. The sorted colors list is passed and are appended in the sheet as required Parameters: type arg_colorlist: list of strings A python list containing the different colours of all packages Function for updating incoming orders sheet - update_incoming(arg_list): This function appends the IncomingOrders sheet of the inventory management spreadsheet. Parameters: type arg_list: list of strings A python list containing the order details that are fetched Function for updating dispatched orders sheet - update_dispatch(arg_list): This function appends the OrdersDispatched sheet of the inventory management spreadsheet. Parameters: type arg_list: list of strings A python list containing the order details that are fetched Function for updating shipped orders sheet - update_shipped(arg_list): This function appends the OrdersShipped sheet of the inventory management spreadsheet. Parameters: type arg_list: list of strings A python list containing the order details that are fetched","title":"IoT"},{"location":"iot/#this-documentation-covers-the-working-of-the-iot-py-file","text":"","title":"This Documentation covers the working of the IoT py file"},{"location":"iot/#function-for-updating-inventory-sheet","text":"- update_inventory(arg_colorlist): This function appends the inventory sheet of the inventory management spreadsheet. The sorted colors list is passed and are appended in the sheet as required Parameters: type arg_colorlist: list of strings A python list containing the different colours of all packages","title":"Function for updating inventory sheet"},{"location":"iot/#function-for-updating-incoming-orders-sheet","text":"- update_incoming(arg_list): This function appends the IncomingOrders sheet of the inventory management spreadsheet. Parameters: type arg_list: list of strings A python list containing the order details that are fetched","title":"Function for updating incoming orders sheet"},{"location":"iot/#function-for-updating-dispatched-orders-sheet","text":"- update_dispatch(arg_list): This function appends the OrdersDispatched sheet of the inventory management spreadsheet. Parameters: type arg_list: list of strings A python list containing the order details that are fetched","title":"Function for updating dispatched orders sheet"},{"location":"iot/#function-for-updating-shipped-orders-sheet","text":"- update_shipped(arg_list): This function appends the OrdersShipped sheet of the inventory management spreadsheet. Parameters: type arg_list: list of strings A python list containing the order details that are fetched","title":"Function for updating shipped orders sheet"},{"location":"msg/","text":"This Documentation covers the different message files contained in pkg_ros_iot_bridge and pkg_task5 msgMqttSub.msg directory - pkg_ros_iot_bridge/msg time timestamp string topic string message This is the .msg file message that stores the data/message received at the mqtt topic msgOrder.msg directory - pkg_task5/msg string order_id This is the .msg file message that stores the order details of a package that is going to be dispatched msgColor.msg directory - pkg_task5/msg string color This is the .msg file message that stores the color of each package as received using 2d camera","title":"the .msg files"},{"location":"msg/#this-documentation-covers-the-different-message-files-contained-in-pkg_ros_iot_bridge-and-pkg_task5","text":"","title":"This Documentation covers the different message files contained in pkg_ros_iot_bridge and pkg_task5"},{"location":"msg/#msgmqttsubmsg","text":"directory - pkg_ros_iot_bridge/msg time timestamp string topic string message This is the .msg file message that stores the data/message received at the mqtt topic","title":"msgMqttSub.msg"},{"location":"msg/#msgordermsg","text":"directory - pkg_task5/msg string order_id This is the .msg file message that stores the order details of a package that is going to be dispatched","title":"msgOrder.msg"},{"location":"msg/#msgcolormsg","text":"directory - pkg_task5/msg string color This is the .msg file message that stores the color of each package as received using 2d camera","title":"msgColor.msg"},{"location":"node_t5_u1/","text":"This Documentation covers the Code related to Dispatching the package Class IotActionClient This Class is to use methods related to Action client for an action server. 1. __init__(self): creates a class for the action client, to send goals to the action server. This time to publish/append Data from the UR5_2 arm side to the google spreadsheet 2. on_transition(self, goal_handle): function generated during transition of goal Parameters ------------------ :type goal_handle: list : Contains the goal to be sent in a python list format ------------------ Is called when the send goal method is called 3. send_goal(self, arg_topic, arg_string): function to send goal to action server Python list and string methods are called and a goal is sent to the action server Parameters ------------------ :type arg_topic: string : the name of the method that selects which spreadsheet to update :type arg_list: list : the message that has to be appended in the google sheet Class CartesianPath This class is used for methods related to the moveit UR5 arm 1 __init__(self, arg_robot_name): This constructs an object for UR5 moveit class which finds the package on the conveyor belt and drops it into the respective bin Parameters: type arg_robot_name: string it is the UR5 arm which we are trying to use 2 go_to_pose(self, arg_pose): This function makes the UR5 arm to go to a particular pose for which Inverse Kinematics is valid Parameters: type arg_pose: geometry_msgs msg Set of valid coordinates 3 set_joint_angles(self, arg_list_joint_angles): This function sets the different joints of UR5 arm to the given value Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle 4 hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): This function sets the different joints of UR5 arm to the given value. It loops through a range until the result is achieved Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle type arg_max_attempts: Int value for range The number of attempts to set the joint angles 5 attach_box(self, box_name, timeout=4): This Function attaches a given package to the end effector in both Gazebo and Moveit, so that it can form a collision free path. it also uses the Vaccum gripper Service Parameters: type box_name: string name of the package 6 detach_box(self, arg_name, timeout=4): This Function detaches a given package to the end effector in both Gazebo and Moveit it also uses the Vaccum gripper Service Parameters: type box_name: string name of the package 7 remove_object(self, arg_name, timeout=4): This Function removes a package from the planning scene in moveit Parameters: type box_name: string name of the package 8 moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): This function loads the yaml file containing the already travelled path by a UR5 arm between two poses Parameters: type arg_file_path: string The directory where the yaml file is stored type arg_file_name: string The name of the yaml file to load 9 moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts): This function loads the yaml file containing the already travelled path by a UR5 arm between two poses until true while looping for a given number of attempts Parameters: type arg_file_path: string The directory where the yaml file is stored type arg_file_name: string The name of the yaml file to load type arg_max_attempts: Int value for range The number of attempts to set the joint angles Class Camera1 class to access 2d camera 1. get_qr_data(self, arg_image): This function uses the decode attribute of pyzbar then we sort the packages according to the Rect Coordinates and save the sorted color list at self.qr Parameters: type arg_image: Numpy Array An image in the form of a numpy array 2. callback(self, data): callback fn called when 2d camera topic is subscribed Parameters: type data: 2d Camera Message Message received using 2d camera Sending Order Details To send order details to the second node sendorder(s1, s2, s3): This function gets the order details bound with the package just disptached and publishes it on a topic for the 2nd node to access it also it waits till any one subscribes to the topic Parameters: type s1: string the order ID of the package type s2: String City of Order type s3: String Order Quantity Getting Package get_pkg(arg_name, arg_list): This function plays the saved trajectory to the package that it gets from select_pkg function Then appends the data to the Orders Dispatch sheet and deletes the instance of the order details globaly Parameters: type arg_name: string the name of the package type arg_list: list List containing the order details of the package that has to be sent Selecting Package select_pkg(arg_list): This function finds out which package to select using their order ID. Since each Order ID is unique, we made the Code find the package to dispatch using the order ID 2 Threads are made - One to get the required package One to send the order details of that package to node 2 Parameters: type arg_list: list List containing the order details of the package that has to be sent Callback Function for Incoming Orders func_callback(data): This function gets messages from the \"Incoming Orders\" rostopic and append it to a global list called lst_order. Appends the data to the Incoming Orders Sheet Parameters: type data: Rostopic Message Data contained in the rostopic message Sending Package Colours sendcolor(lst): This function gets the sorted color list for all the package and then publish it on a topic for the 2nd node to access it also it waits till any one subscribes to the topic Parameters: type arg_list: list List containing the colour names of different packages Main Function The Main Function- Starts the conveyor belt Gets the value of different colors of the packages and calls sendorder Appends data into the Inventory Sheet Constantly Subscribed to the Rostopic to get incoming orders from Action Server \"\"\" to make sure that the High priority orders , those with order ID starting with 1 is sent first, we are sorting the incoming orders list in descending order and then select the last element of the list \"\"\"","title":"Node-1"},{"location":"node_t5_u1/#this-documentation-covers-the-code-related-to-dispatching-the-package","text":"","title":"This Documentation covers the Code related to Dispatching the package"},{"location":"node_t5_u1/#class-iotactionclient","text":"This Class is to use methods related to Action client for an action server. 1. __init__(self): creates a class for the action client, to send goals to the action server. This time to publish/append Data from the UR5_2 arm side to the google spreadsheet 2. on_transition(self, goal_handle): function generated during transition of goal Parameters ------------------ :type goal_handle: list : Contains the goal to be sent in a python list format ------------------ Is called when the send goal method is called 3. send_goal(self, arg_topic, arg_string): function to send goal to action server Python list and string methods are called and a goal is sent to the action server Parameters ------------------ :type arg_topic: string : the name of the method that selects which spreadsheet to update :type arg_list: list : the message that has to be appended in the google sheet","title":"Class IotActionClient"},{"location":"node_t5_u1/#class-cartesianpath","text":"This class is used for methods related to the moveit UR5 arm 1 __init__(self, arg_robot_name): This constructs an object for UR5 moveit class which finds the package on the conveyor belt and drops it into the respective bin Parameters: type arg_robot_name: string it is the UR5 arm which we are trying to use 2 go_to_pose(self, arg_pose): This function makes the UR5 arm to go to a particular pose for which Inverse Kinematics is valid Parameters: type arg_pose: geometry_msgs msg Set of valid coordinates 3 set_joint_angles(self, arg_list_joint_angles): This function sets the different joints of UR5 arm to the given value Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle 4 hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): This function sets the different joints of UR5 arm to the given value. It loops through a range until the result is achieved Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle type arg_max_attempts: Int value for range The number of attempts to set the joint angles 5 attach_box(self, box_name, timeout=4): This Function attaches a given package to the end effector in both Gazebo and Moveit, so that it can form a collision free path. it also uses the Vaccum gripper Service Parameters: type box_name: string name of the package 6 detach_box(self, arg_name, timeout=4): This Function detaches a given package to the end effector in both Gazebo and Moveit it also uses the Vaccum gripper Service Parameters: type box_name: string name of the package 7 remove_object(self, arg_name, timeout=4): This Function removes a package from the planning scene in moveit Parameters: type box_name: string name of the package 8 moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): This function loads the yaml file containing the already travelled path by a UR5 arm between two poses Parameters: type arg_file_path: string The directory where the yaml file is stored type arg_file_name: string The name of the yaml file to load 9 moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max_attempts): This function loads the yaml file containing the already travelled path by a UR5 arm between two poses until true while looping for a given number of attempts Parameters: type arg_file_path: string The directory where the yaml file is stored type arg_file_name: string The name of the yaml file to load type arg_max_attempts: Int value for range The number of attempts to set the joint angles","title":"Class CartesianPath"},{"location":"node_t5_u1/#class-camera1","text":"class to access 2d camera 1. get_qr_data(self, arg_image): This function uses the decode attribute of pyzbar then we sort the packages according to the Rect Coordinates and save the sorted color list at self.qr Parameters: type arg_image: Numpy Array An image in the form of a numpy array 2. callback(self, data): callback fn called when 2d camera topic is subscribed Parameters: type data: 2d Camera Message Message received using 2d camera","title":"Class Camera1"},{"location":"node_t5_u1/#sending-order-details","text":"To send order details to the second node sendorder(s1, s2, s3): This function gets the order details bound with the package just disptached and publishes it on a topic for the 2nd node to access it also it waits till any one subscribes to the topic Parameters: type s1: string the order ID of the package type s2: String City of Order type s3: String Order Quantity","title":"Sending Order Details"},{"location":"node_t5_u1/#getting-package","text":"get_pkg(arg_name, arg_list): This function plays the saved trajectory to the package that it gets from select_pkg function Then appends the data to the Orders Dispatch sheet and deletes the instance of the order details globaly Parameters: type arg_name: string the name of the package type arg_list: list List containing the order details of the package that has to be sent","title":"Getting Package"},{"location":"node_t5_u1/#selecting-package","text":"select_pkg(arg_list): This function finds out which package to select using their order ID. Since each Order ID is unique, we made the Code find the package to dispatch using the order ID 2 Threads are made - One to get the required package One to send the order details of that package to node 2 Parameters: type arg_list: list List containing the order details of the package that has to be sent","title":"Selecting Package"},{"location":"node_t5_u1/#callback-function-for-incoming-orders","text":"func_callback(data): This function gets messages from the \"Incoming Orders\" rostopic and append it to a global list called lst_order. Appends the data to the Incoming Orders Sheet Parameters: type data: Rostopic Message Data contained in the rostopic message","title":"Callback Function for Incoming Orders"},{"location":"node_t5_u1/#sending-package-colours","text":"sendcolor(lst): This function gets the sorted color list for all the package and then publish it on a topic for the 2nd node to access it also it waits till any one subscribes to the topic Parameters: type arg_list: list List containing the colour names of different packages","title":"Sending Package Colours"},{"location":"node_t5_u1/#main-function","text":"The Main Function- Starts the conveyor belt Gets the value of different colors of the packages and calls sendorder Appends data into the Inventory Sheet Constantly Subscribed to the Rostopic to get incoming orders from Action Server \"\"\" to make sure that the High priority orders , those with order ID starting with 1 is sent first, we are sorting the incoming orders list in descending order and then select the last element of the list \"\"\"","title":"Main Function"},{"location":"node_t5_u2/","text":"This Documentation covers the Code related to Shipping the package Class IotActionClient This Class is to use methods related to Action client for an action server. 1. __init__(self): creates a class for the action client, to send goals to the action server. This time to publish/append Data from the UR5_2 arm side to the google spreadsheet 2. on_transition(self, goal_handle): function generated during transition of goal Parameters ------------------ :type goal_handle: list : Contains the goal to be sent in a python list format ------------------ Is called when the send goal method is called 3. send_goal(self, arg_topic, arg_string): function to send goal to action server Python list and string methods are called and a goal is sent to the action server Parameters ------------------ :type arg_topic: string : the name of the method that selects which spreadsheet to update :type arg_sring: string : the message that has to be appended in the google sheet Class CartesianPath This class is used for methods related to the moveit UR5 arm 1 __init__(self, arg_robot_name): This constructs an object for UR5 moveit class which finds the package on the conveyor belt and drops it into the respective bin Parameters: type arg_robot_name: string it is the UR5 arm which we are trying to use 2 go_to_pose(self, arg_pose): This function makes the UR5 arm to go to a particular pose for which Inverse Kinematics is valid Parameters: type arg_pose: geometry_msgs msg Set of valid coordinates 3 set_joint_angles(self, arg_list_joint_angles): This function sets the different joints of UR5 arm to the given value Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle 4 hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): This function sets the different joints of UR5 arm to the given value. It loops through a range until the result is achieved Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle type arg_max_attempts: Int value for range The number of attempts to set the joint angles 5 go_home(self): function used to set joint angles to reach the conveyor belt Uses the hard set joint angle method 6 check_count(self, stri): This function checks the name of the package and find its color using the color list that 2d camera sent to this node Parameters: type stri: string contains the package name for which the bin is checked Result : i : integer value which indexes to the color of the required package 7 go_to_bin(self, col): This functions goes to the respective colored bin for each package and after detaching it calls the conveyor belt to full power After we drop the package, the conveyor belt is started again and the ur5 goes to the home position. Meanwhile the Shipped Orders sheet is appended with the data Parameters: type col: string It is a string value which tells us about the colour of the package to drop it into the same colored bin 8 func_cb3(self, data): This functions is the callback function for the '/get_order' rostopic which contains the order details of the package recieved Parameters : type data: string The message received from the rostopic 9 func_cb2(self, data): callback function for logical camera 2 when the package is just under the ee link of ur5_2, it is stopped then conveyorbelt is stopped and package is attached Parameters : type data: Logical Camera Message The set of information that is provided by the logical Camera 2 Callback function to get colours of respective Packages callback function for subscribing to the rostopic to get the sorted colors list Parameters ------------------ :type data: string : The message received from the rostopic Main Function The main function subscribes and collect the lists of colors of package from node 1. Then is constantly subscribed to the logical camera 2 to get the pakcage and drop it for shipping the package","title":"Node-2"},{"location":"node_t5_u2/#this-documentation-covers-the-code-related-to-shipping-the-package","text":"","title":"This Documentation covers the Code related to Shipping the package"},{"location":"node_t5_u2/#class-iotactionclient","text":"This Class is to use methods related to Action client for an action server. 1. __init__(self): creates a class for the action client, to send goals to the action server. This time to publish/append Data from the UR5_2 arm side to the google spreadsheet 2. on_transition(self, goal_handle): function generated during transition of goal Parameters ------------------ :type goal_handle: list : Contains the goal to be sent in a python list format ------------------ Is called when the send goal method is called 3. send_goal(self, arg_topic, arg_string): function to send goal to action server Python list and string methods are called and a goal is sent to the action server Parameters ------------------ :type arg_topic: string : the name of the method that selects which spreadsheet to update :type arg_sring: string : the message that has to be appended in the google sheet","title":"Class IotActionClient"},{"location":"node_t5_u2/#class-cartesianpath","text":"This class is used for methods related to the moveit UR5 arm 1 __init__(self, arg_robot_name): This constructs an object for UR5 moveit class which finds the package on the conveyor belt and drops it into the respective bin Parameters: type arg_robot_name: string it is the UR5 arm which we are trying to use 2 go_to_pose(self, arg_pose): This function makes the UR5 arm to go to a particular pose for which Inverse Kinematics is valid Parameters: type arg_pose: geometry_msgs msg Set of valid coordinates 3 set_joint_angles(self, arg_list_joint_angles): This function sets the different joints of UR5 arm to the given value Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle 4 hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): This function sets the different joints of UR5 arm to the given value. It loops through a range until the result is achieved Parameters: type arg_list_joint_angles: List of angles in Radians Different Angles ranging from -180 to +180 for each joint angle type arg_max_attempts: Int value for range The number of attempts to set the joint angles 5 go_home(self): function used to set joint angles to reach the conveyor belt Uses the hard set joint angle method 6 check_count(self, stri): This function checks the name of the package and find its color using the color list that 2d camera sent to this node Parameters: type stri: string contains the package name for which the bin is checked Result : i : integer value which indexes to the color of the required package 7 go_to_bin(self, col): This functions goes to the respective colored bin for each package and after detaching it calls the conveyor belt to full power After we drop the package, the conveyor belt is started again and the ur5 goes to the home position. Meanwhile the Shipped Orders sheet is appended with the data Parameters: type col: string It is a string value which tells us about the colour of the package to drop it into the same colored bin 8 func_cb3(self, data): This functions is the callback function for the '/get_order' rostopic which contains the order details of the package recieved Parameters : type data: string The message received from the rostopic 9 func_cb2(self, data): callback function for logical camera 2 when the package is just under the ee link of ur5_2, it is stopped then conveyorbelt is stopped and package is attached Parameters : type data: Logical Camera Message The set of information that is provided by the logical Camera 2","title":"Class CartesianPath"},{"location":"node_t5_u2/#callback-function-to-get-colours-of-respective-packages","text":"callback function for subscribing to the rostopic to get the sorted colors list Parameters ------------------ :type data: string : The message received from the rostopic","title":"Callback function to get colours of respective Packages"},{"location":"node_t5_u2/#main-function","text":"The main function subscribes and collect the lists of colors of package from node 1. Then is constantly subscribed to the logical camera 2 to get the pakcage and drop it for shipping the package","title":"Main Function"},{"location":"rib/","text":"This Documentation covers the working of the Action Server node Class IotRosBridgeActionServer class for the action server - __init__(self): # constructor Constructs the object for the Action Server It also Subscribes to the Mqtt topic to constantly get orders that are spawned - mqtt_sub_callback(self, client, userdata, message): This function subscribes to mqtt topic to check for incoming orders and then publishes it on a rostopic - on_goal(self, goal_handle): function generated during receiving of goal Parameters: type goal_handle: list Contains the goal sent in a python list format - process_goal(self, goal_handle): function generated to process goal Parameters: type goal_handle: list Contains the goal sent in a python list format Main Function A rospy node is made and an action server class object is constructed.","title":"Action-Server"},{"location":"rib/#this-documentation-covers-the-working-of-the-action-server-node","text":"","title":"This Documentation covers the working of the Action Server node"},{"location":"rib/#class-iotrosbridgeactionserver","text":"class for the action server - __init__(self): # constructor Constructs the object for the Action Server It also Subscribes to the Mqtt topic to constantly get orders that are spawned - mqtt_sub_callback(self, client, userdata, message): This function subscribes to mqtt topic to check for incoming orders and then publishes it on a rostopic - on_goal(self, goal_handle): function generated during receiving of goal Parameters: type goal_handle: list Contains the goal sent in a python list format - process_goal(self, goal_handle): function generated to process goal Parameters: type goal_handle: list Contains the goal sent in a python list format","title":"Class IotRosBridgeActionServer"},{"location":"rib/#main-function","text":"A rospy node is made and an action server class object is constructed.","title":"Main Function"},{"location":"summary/","text":"This is Our way of solving the Vargi Bot Theme Problem of Eyantra Competition 2020-21 hello all, our team is VB#602 and the following is a brief explanation of our task run Our program consists of 2 main nodes: node_t5_u1.py - for dispatching node_t5_u2.py - for shipping Each Node has a different function The First node deals with eveything on the left side of the task world. It extracts the image of package from 2d camera and also uses the UR5_1 arm. The Second node deals with everything on the right side of the task world. It uses the UR5_2 arm. Implementation - Proper Explanation of each block of code The following is our video of task run","title":"Summary"},{"location":"summary/#our-program-consists-of-2-main-nodes","text":"node_t5_u1.py - for dispatching node_t5_u2.py - for shipping","title":"Our program consists of 2 main nodes:"},{"location":"summary/#each-node-has-a-different-function","text":"The First node deals with eveything on the left side of the task world. It extracts the image of package from 2d camera and also uses the UR5_1 arm. The Second node deals with everything on the right side of the task world. It uses the UR5_2 arm. Implementation - Proper Explanation of each block of code","title":"Each Node has a different function"},{"location":"summary/#the-following-is-our-video-of-task-run","text":"","title":"The following is our video of task run"}]}